local M = {}
local fs = vim.fs
local fn = vim.fn

---@class SelectaColorschemeOptions
---@field persist? boolean
---@field write_shada? boolean

-- Default options
local default_options = {
  persist = false,
  write_shada = false,
}

local function setup_persistence()
  local config_dir = fn.stdpath("config")
  local plugin_dir = config_dir .. "/plugin"
  local persistence_file = plugin_dir .. "/selecta_colorscheme_persist.lua"

  -- Create plugin directory if it doesn't exist
  if not fs.dir(plugin_dir) then
    fn.mkdir(plugin_dir, "p")
  end

  -- Create persistence file if it doesn't exist
  if not fs.file_readable(persistence_file) then
    local content = [[
-- Persisted colorscheme module (auto-generated by selecta.nvim)
vim.g.SCHEME = "default"

vim.api.nvim_create_autocmd("VimEnter", {
  callback = function()
    pcall(vim.cmd.colorscheme, vim.g.SCHEME)
  end,
})

vim.api.nvim_create_autocmd("ColorScheme", {
  callback = function(params)
    vim.g.SCHEME = params.match
  end,
})
]]
    local file = io.open(persistence_file, "w")
    if file then
      file:write(content)
      file:close()
    end
  end
end

local function colorscheme_picker(opts)
  -- Get the current colorscheme
  local original_colorscheme = vim.g.colors_name

  -- Get a list of available colorschemes
  local colorschemes = vim.fn.getcompletion("", "color")

  local default_colorschemes = {
    "vim",
    "blue",
    "darkblue",
    "default",
    "delek",
    "desert",
    "elflord",
    "evening",
    "habamax",
    "industry",
    "koehler",
    "lunaperche",
    "morning",
    "murphy",
    "pablo",
    "peachpuff",
    "quiet",
    "ron",
    "shine",
    "slate",
    "torte",
    "zellner",
  }

  -- Filter out default colorschemes except "default"
  colorschemes = vim.tbl_filter(function(scheme)
    return scheme == "default" or not vim.tbl_contains(default_colorschemes, scheme)
  end, colorschemes)

  -- Convert colorschemes into selecta-compatible items
  local items = vim.tbl_map(function(scheme)
    return {
      text = scheme,
      value = scheme,
      icon = "ðŸŽ¨",
      kind = "Colorscheme",
    }
  end, colorschemes)

  -- Find the index of the current colorscheme
  local initial_index = nil
  for i, item in ipairs(items) do
    if item.value == original_colorscheme then
      initial_index = i
      break
    end
  end

  local selecta = require("selecta.selecta")
  selecta.pick(items, {
    title = "Select Colorscheme",
    initial_index = initial_index,
    display = {
      mode = "icon",
      padding = 1,
    },
    window = {
      border = "none",
      title_prefix = "ðŸŽ¨ ",
      auto_size = true,
      min_width = 20,
    },
    on_select = function(item)
      if item then
        vim.cmd.colorscheme(item.value)
        if opts.write_shada then
          vim.cmd("wshada!")
        end
        vim.notify("Colorscheme set to: " .. item.value, vim.log.levels.INFO)
      else
        vim.notify("No colorscheme selected.", vim.log.levels.WARN)
      end
    end,
    on_cancel = function()
      vim.cmd.colorscheme(original_colorscheme)
    end,
    on_move = function(item)
      if item then
        vim.wait(2, function()
          return vim.cmd.colorscheme(item.value)
        end)
      end
    end,
  })
end

function M.setup(options)
  options = vim.tbl_deep_extend("force", default_options, options or {})

  -- Set up persistence if enabled
  if options.persist then
    setup_persistence()
  end

  -- Create user command
  vim.api.nvim_create_user_command("Colorscheme", function()
    colorscheme_picker(options)
  end, {})
end

return M
